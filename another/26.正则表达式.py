# 正则表达式
import re

# 总结   []   ^   $   \  ?  *  +

# 正则表达式需要借助 re
# 写一个小爬虫
s1 = 'abc'
# 普通正则
s2 = r'abc'
# 普通正则里存在一个字符集,字符集里的情况都可以
s3 = r'a[bcd]c'
# 非bcd的情况都可以
s4 = r'a[^bcd]c'
# 如果^放在不是开头的位置当做普通符号
s5 = r'a[bcd^]c'
# 匹配行首
s6 = r'^abc'
# 匹配行尾
s7 = r'abc$'
# 匹配数字 0-9
s8 = r'[0-9]'
s8 = r'\d'
# 匹配非数字0-9
s8 = r'[^0-9]'
s8 = r'\D'
# 匹配空白字符
ss = r'\s'
# 匹配非空白字符
ss = r'\S'
# 匹配任何字母数字字符(包括下划线)
sw = r'[a-zA-Z0-9_]'
sw = r'\w'
# 匹配任何非字母数字字符
sw = r'\W'
# 如果想要取^abc,在规则当中将^转换为普通符号,用反斜杠转义
s10 = r'\^abc'
# 匹配不定长的字符集,指定一部分字符集重复的次数
# 举例:匹配电话号码,数字可以出现8次------------------{
mobile = '010-12345678'
sm = r'^010-\d{1,3}'
# 举例:最少重复3次,最多重复8次
# sm = r'^010\d{3,8}'
# 举例:{0,}等同于*,{1,}等同于+,{0,1}等同于?
# 举例:匹配b可以出现0-N次---------------------------*
st = r'a[b]*'
str = 'abbbbbbbaab'
# 举例:匹配一次或更多次(至少一次)--------------------+
# st1 = r'ab+'
# 举例:匹配一次或零次-------------------------------?
st2 = r'ab?'
# 电话号码中间的-可有可无的情况下可以使用?
# sm = r'^010-?\d{8}'
# 非贪婪匹配,让重复次数变为最小匹配数为1
st1 = r'ab+?'

print(re.findall(sw, '12345678_'))
print(re.findall(sm, mobile))
print(re.findall(st1, str))
